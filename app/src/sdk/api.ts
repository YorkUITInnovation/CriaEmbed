/* tslint:disable */
/* eslint-disable */
/**
 * Cria Embed API
 * API for embedding Cria into web-pages on the world wide interwebs!
 *
 * The version of the OpenAPI document: 1.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const BotLocale = {
    EnUs: 'en-US',
    FrFr: 'fr-FR'
} as const;

export type BotLocale = typeof BotLocale[keyof typeof BotLocale];


/**
 * 
 * @export
 * @interface ChatAudioResponse
 */
export interface ChatAudioResponse {
    /**
     * Construct a type with a set of properties K of type T
     * @type {object}
     * @memberof ChatAudioResponse
     */
    'detail'?: object;
    /**
     * 
     * @type {string}
     * @memberof ChatAudioResponse
     */
    'message': string;
    /**
     * 
     * @type {CriaResponseCode}
     * @memberof ChatAudioResponse
     */
    'code': CriaResponseCode;
    /**
     * 
     * @type {string}
     * @memberof ChatAudioResponse
     */
    'timestamp': string;
    /**
     * 
     * @type {CriaResponseStatus}
     * @memberof ChatAudioResponse
     */
    'status': CriaResponseStatus;
}


/**
 * 
 * @export
 * @interface ChatGenerateSpeech200Response
 */
export interface ChatGenerateSpeech200Response {
    /**
     * Construct a type with a set of properties K of type T
     * @type {object}
     * @memberof ChatGenerateSpeech200Response
     */
    'detail'?: object;
    /**
     * 
     * @type {string}
     * @memberof ChatGenerateSpeech200Response
     */
    'message': string;
    /**
     * 
     * @type {CriaResponseCode}
     * @memberof ChatGenerateSpeech200Response
     */
    'code': CriaResponseCode;
    /**
     * 
     * @type {string}
     * @memberof ChatGenerateSpeech200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {CriaResponseStatus}
     * @memberof ChatGenerateSpeech200Response
     */
    'status': CriaResponseStatus;
}


/**
 * 
 * @export
 * @interface ChatPayload
 */
export interface ChatPayload {
    /**
     * 
     * @type {string}
     * @memberof ChatPayload
     */
    'prompt': string;
    /**
     * 
     * @type {string}
     * @memberof ChatPayload
     */
    'chatId': string;
}
/**
 * 
 * @export
 * @interface CreateChatResponse
 */
export interface CreateChatResponse {
    /**
     * Construct a type with a set of properties K of type T
     * @type {object}
     * @memberof CreateChatResponse
     */
    'detail'?: object;
    /**
     * 
     * @type {string}
     * @memberof CreateChatResponse
     */
    'message': string;
    /**
     * 
     * @type {CriaResponseCode}
     * @memberof CreateChatResponse
     */
    'code': CriaResponseCode;
    /**
     * 
     * @type {string}
     * @memberof CreateChatResponse
     */
    'timestamp': string;
    /**
     * 
     * @type {CriaResponseStatus}
     * @memberof CreateChatResponse
     */
    'status': CriaResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof CreateChatResponse
     */
    'chatId': string | null;
}


/**
 * 
 * @export
 * @interface CriaResponse
 */
export interface CriaResponse {
    /**
     * Construct a type with a set of properties K of type T
     * @type {object}
     * @memberof CriaResponse
     */
    'detail'?: object;
    /**
     * 
     * @type {string}
     * @memberof CriaResponse
     */
    'message': string;
    /**
     * 
     * @type {CriaResponseCode}
     * @memberof CriaResponse
     */
    'code': CriaResponseCode;
    /**
     * 
     * @type {string}
     * @memberof CriaResponse
     */
    'timestamp': string;
    /**
     * 
     * @type {CriaResponseStatus}
     * @memberof CriaResponse
     */
    'status': CriaResponseStatus;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const CriaResponseCode = {
    Error: 'ERROR',
    Unauthorized: 'UNAUTHORIZED',
    Success: 'SUCCESS',
    NotFound: 'NOT_FOUND',
    Duplicate: 'DUPLICATE',
    TooManyRequests: 'TOO_MANY_REQUESTS',
    Invalid: 'INVALID'
} as const;

export type CriaResponseCode = typeof CriaResponseCode[keyof typeof CriaResponseCode];


/**
 * 
 * @export
 * @enum {number}
 */

export const CriaResponseStatus = {
    NUMBER_200: 200,
    NUMBER_300: 300,
    NUMBER_301: 301,
    NUMBER_302: 302,
    NUMBER_401: 401,
    NUMBER_403: 403,
    NUMBER_404: 404,
    NUMBER_405: 405,
    NUMBER_409: 409,
    NUMBER_422: 422,
    NUMBER_429: 429,
    NUMBER_500: 500
} as const;

export type CriaResponseStatus = typeof CriaResponseStatus[keyof typeof CriaResponseStatus];


/**
 * 
 * @export
 * @interface CriabotChatResponseRelatedPrompt
 */
export interface CriabotChatResponseRelatedPrompt {
    /**
     * 
     * @type {string}
     * @memberof CriabotChatResponseRelatedPrompt
     */
    'prompt': string;
    /**
     * 
     * @type {string}
     * @memberof CriabotChatResponseRelatedPrompt
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface DeleteResponse
 */
export interface DeleteResponse {
    /**
     * Construct a type with a set of properties K of type T
     * @type {object}
     * @memberof DeleteResponse
     */
    'detail'?: object;
    /**
     * 
     * @type {string}
     * @memberof DeleteResponse
     */
    'message': string;
    /**
     * 
     * @type {CriaResponseCode}
     * @memberof DeleteResponse
     */
    'code': CriaResponseCode;
    /**
     * 
     * @type {string}
     * @memberof DeleteResponse
     */
    'timestamp': string;
    /**
     * 
     * @type {CriaResponseStatus}
     * @memberof DeleteResponse
     */
    'status': CriaResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof DeleteResponse
     */
    'botName'?: string;
}


/**
 * 
 * @export
 * @interface EmbedConfigResponse
 */
export interface EmbedConfigResponse {
    /**
     * Construct a type with a set of properties K of type T
     * @type {object}
     * @memberof EmbedConfigResponse
     */
    'detail'?: object;
    /**
     * 
     * @type {string}
     * @memberof EmbedConfigResponse
     */
    'message': string;
    /**
     * 
     * @type {CriaResponseCode}
     * @memberof EmbedConfigResponse
     */
    'code': CriaResponseCode;
    /**
     * 
     * @type {string}
     * @memberof EmbedConfigResponse
     */
    'timestamp': string;
    /**
     * 
     * @type {CriaResponseStatus}
     * @memberof EmbedConfigResponse
     */
    'status': CriaResponseStatus;
    /**
     * 
     * @type {EmbedPublicConfig}
     * @memberof EmbedConfigResponse
     */
    'config'?: EmbedPublicConfig;
}


/**
 * 
 * @export
 * @interface EmbedGetLoader200Response
 */
export interface EmbedGetLoader200Response {
    /**
     * Construct a type with a set of properties K of type T
     * @type {object}
     * @memberof EmbedGetLoader200Response
     */
    'detail'?: object;
    /**
     * 
     * @type {string}
     * @memberof EmbedGetLoader200Response
     */
    'message': string;
    /**
     * 
     * @type {CriaResponseCode}
     * @memberof EmbedGetLoader200Response
     */
    'code': CriaResponseCode;
    /**
     * 
     * @type {string}
     * @memberof EmbedGetLoader200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {CriaResponseStatus}
     * @memberof EmbedGetLoader200Response
     */
    'status': CriaResponseStatus;
}


/**
 * 
 * @export
 * @interface EmbedGetSession200Response
 */
export interface EmbedGetSession200Response {
    /**
     * Construct a type with a set of properties K of type T
     * @type {object}
     * @memberof EmbedGetSession200Response
     */
    'detail'?: object;
    /**
     * 
     * @type {string}
     * @memberof EmbedGetSession200Response
     */
    'message': string;
    /**
     * 
     * @type {CriaResponseCode}
     * @memberof EmbedGetSession200Response
     */
    'code': CriaResponseCode;
    /**
     * 
     * @type {string}
     * @memberof EmbedGetSession200Response
     */
    'timestamp': string;
    /**
     * 
     * @type {CriaResponseStatus}
     * @memberof EmbedGetSession200Response
     */
    'status': CriaResponseStatus;
    /**
     * Construct a type with a set of properties K of type T
     * @type {object}
     * @memberof EmbedGetSession200Response
     */
    'sessionData': object | null;
}


/**
 * 
 * @export
 * @enum {number}
 */

export const EmbedPosition = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type EmbedPosition = typeof EmbedPosition[keyof typeof EmbedPosition];


/**
 * 
 * @export
 * @interface EmbedPublicConfig
 */
export interface EmbedPublicConfig {
    /**
     * 
     * @type {string}
     * @memberof EmbedPublicConfig
     */
    'botContact'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmbedPublicConfig
     */
    'botTrustWarning'?: string | null;
    /**
     * 
     * @type {Array<CriabotChatResponseRelatedPrompt>}
     * @memberof EmbedPublicConfig
     */
    'initialPrompts'?: Array<CriabotChatResponseRelatedPrompt> | null;
    /**
     * 
     * @type {BotLocale}
     * @memberof EmbedPublicConfig
     */
    'botLocale': BotLocale;
    /**
     * 
     * @type {boolean}
     * @memberof EmbedPublicConfig
     */
    'watermarkEnabled'?: boolean | null;
    /**
     * 
     * @type {EmbedPosition}
     * @memberof EmbedPublicConfig
     */
    'embedPosition': EmbedPosition;
    /**
     * 
     * @type {boolean}
     * @memberof EmbedPublicConfig
     */
    'defaultEnabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof EmbedPublicConfig
     */
    'embedTheme': string | null;
    /**
     * 
     * @type {string}
     * @memberof EmbedPublicConfig
     */
    'botIconUrl': string;
    /**
     * 
     * @type {string}
     * @memberof EmbedPublicConfig
     */
    'botGreetingId': string;
    /**
     * 
     * @type {string}
     * @memberof EmbedPublicConfig
     */
    'botGreeting': string;
    /**
     * 
     * @type {string}
     * @memberof EmbedPublicConfig
     */
    'botSubName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmbedPublicConfig
     */
    'botName': string;
    /**
     * 
     * @type {string}
     * @memberof EmbedPublicConfig
     */
    'botId': string;
}


/**
 * 
 * @export
 * @interface ExistsChatResponse
 */
export interface ExistsChatResponse {
    /**
     * Construct a type with a set of properties K of type T
     * @type {object}
     * @memberof ExistsChatResponse
     */
    'detail'?: object;
    /**
     * 
     * @type {string}
     * @memberof ExistsChatResponse
     */
    'message': string;
    /**
     * 
     * @type {CriaResponseCode}
     * @memberof ExistsChatResponse
     */
    'code': CriaResponseCode;
    /**
     * 
     * @type {string}
     * @memberof ExistsChatResponse
     */
    'timestamp': string;
    /**
     * 
     * @type {CriaResponseStatus}
     * @memberof ExistsChatResponse
     */
    'status': CriaResponseStatus;
    /**
     * 
     * @type {boolean}
     * @memberof ExistsChatResponse
     */
    'exists': boolean | null;
}


/**
 * 
 * @export
 * @interface IBotBaseEmbedConfig
 */
export interface IBotBaseEmbedConfig {
    /**
     * 
     * @type {string}
     * @memberof IBotBaseEmbedConfig
     */
    'botTitle'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IBotBaseEmbedConfig
     */
    'botSubTitle'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IBotBaseEmbedConfig
     */
    'botGreeting'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IBotBaseEmbedConfig
     */
    'botIconUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IBotBaseEmbedConfig
     */
    'botEmbedTheme'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof IBotBaseEmbedConfig
     */
    'botEmbedDefaultEnabled'?: boolean | null;
    /**
     * 
     * @type {EmbedPosition}
     * @memberof IBotBaseEmbedConfig
     */
    'botEmbedPosition'?: EmbedPosition | null;
    /**
     * 
     * @type {boolean}
     * @memberof IBotBaseEmbedConfig
     */
    'botWatermark'?: boolean | null;
    /**
     * 
     * @type {BotLocale}
     * @memberof IBotBaseEmbedConfig
     */
    'botLocale'?: BotLocale | null;
    /**
     * 
     * @type {string}
     * @memberof IBotBaseEmbedConfig
     */
    'botTrustWarning'?: string | null;
    /**
     * 
     * @type {Array<CriabotChatResponseRelatedPrompt>}
     * @memberof IBotBaseEmbedConfig
     */
    'initialPrompts'?: Array<CriabotChatResponseRelatedPrompt> | null;
    /**
     * 
     * @type {string}
     * @memberof IBotBaseEmbedConfig
     */
    'microsoftAppId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IBotBaseEmbedConfig
     */
    'microsoftAppPassword'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof IBotBaseEmbedConfig
     */
    'integrationsNoContextReply'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof IBotBaseEmbedConfig
     */
    'integrationsFirstEmailOnly'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof IBotBaseEmbedConfig
     */
    'integrationsWhitelistFilter'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IBotBaseEmbedConfig
     */
    'embedHoverTooltip'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IBotBaseEmbedConfig
     */
    'botContact'?: string | null;
}


/**
 * 
 * @export
 * @interface IBotEmbed
 */
export interface IBotEmbed {
    /**
     * 
     * @type {string}
     * @memberof IBotEmbed
     */
    'botTitle'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IBotEmbed
     */
    'botSubTitle'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IBotEmbed
     */
    'botGreeting'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IBotEmbed
     */
    'botIconUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IBotEmbed
     */
    'botEmbedTheme'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof IBotEmbed
     */
    'botEmbedDefaultEnabled'?: boolean | null;
    /**
     * 
     * @type {EmbedPosition}
     * @memberof IBotEmbed
     */
    'botEmbedPosition'?: EmbedPosition | null;
    /**
     * 
     * @type {boolean}
     * @memberof IBotEmbed
     */
    'botWatermark'?: boolean | null;
    /**
     * 
     * @type {BotLocale}
     * @memberof IBotEmbed
     */
    'botLocale'?: BotLocale | null;
    /**
     * 
     * @type {string}
     * @memberof IBotEmbed
     */
    'botTrustWarning'?: string | null;
    /**
     * 
     * @type {Array<CriabotChatResponseRelatedPrompt>}
     * @memberof IBotEmbed
     */
    'initialPrompts'?: Array<CriabotChatResponseRelatedPrompt> | null;
    /**
     * 
     * @type {string}
     * @memberof IBotEmbed
     */
    'microsoftAppId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IBotEmbed
     */
    'microsoftAppPassword'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof IBotEmbed
     */
    'integrationsNoContextReply'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof IBotEmbed
     */
    'integrationsFirstEmailOnly'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof IBotEmbed
     */
    'integrationsWhitelistFilter'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IBotEmbed
     */
    'embedHoverTooltip'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IBotEmbed
     */
    'botContact'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IBotEmbed
     */
    'botName': string;
    /**
     * 
     * @type {number}
     * @memberof IBotEmbed
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof IBotEmbed
     */
    'createdAt'?: string;
}


/**
 * 
 * @export
 * @interface InsertResponse
 */
export interface InsertResponse {
    /**
     * Construct a type with a set of properties K of type T
     * @type {object}
     * @memberof InsertResponse
     */
    'detail'?: object;
    /**
     * 
     * @type {string}
     * @memberof InsertResponse
     */
    'message': string;
    /**
     * 
     * @type {CriaResponseCode}
     * @memberof InsertResponse
     */
    'code': CriaResponseCode;
    /**
     * 
     * @type {string}
     * @memberof InsertResponse
     */
    'timestamp': string;
    /**
     * 
     * @type {CriaResponseStatus}
     * @memberof InsertResponse
     */
    'status': CriaResponseStatus;
    /**
     * 
     * @type {IBotEmbed}
     * @memberof InsertResponse
     */
    'config'?: IBotEmbed;
}


/**
 * 
 * @export
 * @interface RetrieveResponse
 */
export interface RetrieveResponse {
    /**
     * Construct a type with a set of properties K of type T
     * @type {object}
     * @memberof RetrieveResponse
     */
    'detail'?: object;
    /**
     * 
     * @type {string}
     * @memberof RetrieveResponse
     */
    'message': string;
    /**
     * 
     * @type {CriaResponseCode}
     * @memberof RetrieveResponse
     */
    'code': CriaResponseCode;
    /**
     * 
     * @type {string}
     * @memberof RetrieveResponse
     */
    'timestamp': string;
    /**
     * 
     * @type {CriaResponseStatus}
     * @memberof RetrieveResponse
     */
    'status': CriaResponseStatus;
    /**
     * 
     * @type {IBotEmbed}
     * @memberof RetrieveResponse
     */
    'config'?: IBotEmbed;
}


/**
 * 
 * @export
 * @interface SendChatResponse
 */
export interface SendChatResponse {
    /**
     * Construct a type with a set of properties K of type T
     * @type {object}
     * @memberof SendChatResponse
     */
    'detail'?: object;
    /**
     * 
     * @type {string}
     * @memberof SendChatResponse
     */
    'message': string;
    /**
     * 
     * @type {CriaResponseCode}
     * @memberof SendChatResponse
     */
    'code': CriaResponseCode;
    /**
     * 
     * @type {string}
     * @memberof SendChatResponse
     */
    'timestamp': string;
    /**
     * 
     * @type {CriaResponseStatus}
     * @memberof SendChatResponse
     */
    'status': CriaResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof SendChatResponse
     */
    'reply': string | null;
    /**
     * 
     * @type {string}
     * @memberof SendChatResponse
     */
    'replyId': string | null;
    /**
     * 
     * @type {Array<CriabotChatResponseRelatedPrompt>}
     * @memberof SendChatResponse
     */
    'relatedPrompts': Array<CriabotChatResponseRelatedPrompt> | null;
    /**
     * 
     * @type {boolean}
     * @memberof SendChatResponse
     */
    'verifiedResponse': boolean | null;
}


/**
 * 
 * @export
 * @interface SessionDataResponse
 */
export interface SessionDataResponse {
    /**
     * Construct a type with a set of properties K of type T
     * @type {object}
     * @memberof SessionDataResponse
     */
    'detail'?: object;
    /**
     * 
     * @type {string}
     * @memberof SessionDataResponse
     */
    'message': string;
    /**
     * 
     * @type {CriaResponseCode}
     * @memberof SessionDataResponse
     */
    'code': CriaResponseCode;
    /**
     * 
     * @type {string}
     * @memberof SessionDataResponse
     */
    'timestamp': string;
    /**
     * 
     * @type {CriaResponseStatus}
     * @memberof SessionDataResponse
     */
    'status': CriaResponseStatus;
    /**
     * Construct a type with a set of properties K of type T
     * @type {object}
     * @memberof SessionDataResponse
     */
    'sessionData': object | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SpeechLanguage = {
    FrFr: 'fr-FR',
    EnUs: 'en-US'
} as const;

export type SpeechLanguage = typeof SpeechLanguage[keyof typeof SpeechLanguage];


/**
 * 
 * @export
 * @interface UpdateResponse
 */
export interface UpdateResponse {
    /**
     * Construct a type with a set of properties K of type T
     * @type {object}
     * @memberof UpdateResponse
     */
    'detail'?: object;
    /**
     * 
     * @type {string}
     * @memberof UpdateResponse
     */
    'message': string;
    /**
     * 
     * @type {CriaResponseCode}
     * @memberof UpdateResponse
     */
    'code': CriaResponseCode;
    /**
     * 
     * @type {string}
     * @memberof UpdateResponse
     */
    'timestamp': string;
    /**
     * 
     * @type {CriaResponseStatus}
     * @memberof UpdateResponse
     */
    'status': CriaResponseStatus;
    /**
     * 
     * @type {IBotEmbed}
     * @memberof UpdateResponse
     */
    'config'?: IBotEmbed;
}



/**
 * ChatsApi - axios parameter creator
 * @export
 */
export const ChatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatCreate: async (chatId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('chatCreate', 'chatId', chatId)
            const localVarPath = `/chats/{chatId}/create`
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatExists: async (chatId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('chatExists', 'chatId', chatId)
            const localVarPath = `/chats/{chatId}/exists`
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatsApi - functional programming interface
 * @export
 */
export const ChatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatCreate(chatId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateChatResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatCreate(chatId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatsApi.chatCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatExists(chatId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExistsChatResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatExists(chatId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatsApi.chatExists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatsApi - factory interface
 * @export
 */
export const ChatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatCreate(chatId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateChatResponse> {
            return localVarFp.chatCreate(chatId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatExists(chatId: string, options?: RawAxiosRequestConfig): AxiosPromise<ExistsChatResponse> {
            return localVarFp.chatExists(chatId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatsApi - object-oriented interface
 * @export
 * @class ChatsApi
 * @extends {BaseAPI}
 */
export class ChatsApi extends BaseAPI {
    /**
     * 
     * @param {string} chatId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatCreate(chatId: string, options?: RawAxiosRequestConfig) {
        return ChatsApiFp(this.configuration).chatCreate(chatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} chatId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatExists(chatId: string, options?: RawAxiosRequestConfig) {
        return ChatsApiFp(this.configuration).chatExists(chatId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EmbedApi - axios parameter creator
 * @export
 */
export const EmbedApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} chatId 
         * @param {string} messageId 
         * @param {SpeechLanguage} language 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatGenerateSpeech: async (chatId: string, messageId: string, language: SpeechLanguage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('chatGenerateSpeech', 'chatId', chatId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('chatGenerateSpeech', 'messageId', messageId)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('chatGenerateSpeech', 'language', language)
            const localVarPath = `/embed/{chatId}/speech`
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (messageId !== undefined) {
                localVarQueryParameter['messageId'] = messageId;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} botId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        embedGetConfig: async (botId: string, chatId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('embedGetConfig', 'botId', botId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('embedGetConfig', 'chatId', chatId)
            const localVarPath = `/embed/{botId}/config`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = chatId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} botId 
         * @param {boolean} [hideLauncher] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        embedGetLoader: async (botId: string, hideLauncher?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('embedGetLoader', 'botId', botId)
            const localVarPath = `/embed/{botId}/load`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hideLauncher !== undefined) {
                localVarQueryParameter['hideLauncher'] = hideLauncher;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        embedGetPopupHtml: async (botId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('embedGetPopupHtml', 'botId', botId)
            const localVarPath = `/embed/{botId}/popup.html`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} botId 
         * @param {boolean} [hideLauncher] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        embedGetPopupJs: async (botId: string, hideLauncher?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('embedGetPopupJs', 'botId', botId)
            const localVarPath = `/embed/{botId}/popup.js`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hideLauncher !== undefined) {
                localVarQueryParameter['hideLauncher'] = hideLauncher;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} botId 
         * @param {ChatPayload} chatPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        embedSendChat: async (botId: string, chatPayload: ChatPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('embedSendChat', 'botId', botId)
            // verify required parameter 'chatPayload' is not null or undefined
            assertParamExists('embedSendChat', 'chatPayload', chatPayload)
            const localVarPath = `/embed/{botId}/send`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmbedApi - functional programming interface
 * @export
 */
export const EmbedApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmbedApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} chatId 
         * @param {string} messageId 
         * @param {SpeechLanguage} language 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatGenerateSpeech(chatId: string, messageId: string, language: SpeechLanguage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatGenerateSpeech200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatGenerateSpeech(chatId, messageId, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmbedApi.chatGenerateSpeech']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} botId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async embedGetConfig(botId: string, chatId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmbedConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.embedGetConfig(botId, chatId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmbedApi.embedGetConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} botId 
         * @param {boolean} [hideLauncher] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async embedGetLoader(botId: string, hideLauncher?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmbedGetLoader200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.embedGetLoader(botId, hideLauncher, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmbedApi.embedGetLoader']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async embedGetPopupHtml(botId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.embedGetPopupHtml(botId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmbedApi.embedGetPopupHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} botId 
         * @param {boolean} [hideLauncher] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async embedGetPopupJs(botId: string, hideLauncher?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.embedGetPopupJs(botId, hideLauncher, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmbedApi.embedGetPopupJs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} botId 
         * @param {ChatPayload} chatPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async embedSendChat(botId: string, chatPayload: ChatPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendChatResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.embedSendChat(botId, chatPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmbedApi.embedSendChat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EmbedApi - factory interface
 * @export
 */
export const EmbedApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmbedApiFp(configuration)
    return {
        /**
         * 
         * @param {string} chatId 
         * @param {string} messageId 
         * @param {SpeechLanguage} language 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatGenerateSpeech(chatId: string, messageId: string, language: SpeechLanguage, options?: RawAxiosRequestConfig): AxiosPromise<ChatGenerateSpeech200Response> {
            return localVarFp.chatGenerateSpeech(chatId, messageId, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} botId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        embedGetConfig(botId: string, chatId: string, options?: RawAxiosRequestConfig): AxiosPromise<EmbedConfigResponse> {
            return localVarFp.embedGetConfig(botId, chatId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} botId 
         * @param {boolean} [hideLauncher] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        embedGetLoader(botId: string, hideLauncher?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<EmbedGetLoader200Response> {
            return localVarFp.embedGetLoader(botId, hideLauncher, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        embedGetPopupHtml(botId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.embedGetPopupHtml(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} botId 
         * @param {boolean} [hideLauncher] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        embedGetPopupJs(botId: string, hideLauncher?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.embedGetPopupJs(botId, hideLauncher, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} botId 
         * @param {ChatPayload} chatPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        embedSendChat(botId: string, chatPayload: ChatPayload, options?: RawAxiosRequestConfig): AxiosPromise<SendChatResponse> {
            return localVarFp.embedSendChat(botId, chatPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmbedApi - object-oriented interface
 * @export
 * @class EmbedApi
 * @extends {BaseAPI}
 */
export class EmbedApi extends BaseAPI {
    /**
     * 
     * @param {string} chatId 
     * @param {string} messageId 
     * @param {SpeechLanguage} language 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbedApi
     */
    public chatGenerateSpeech(chatId: string, messageId: string, language: SpeechLanguage, options?: RawAxiosRequestConfig) {
        return EmbedApiFp(this.configuration).chatGenerateSpeech(chatId, messageId, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} botId 
     * @param {string} chatId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbedApi
     */
    public embedGetConfig(botId: string, chatId: string, options?: RawAxiosRequestConfig) {
        return EmbedApiFp(this.configuration).embedGetConfig(botId, chatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} botId 
     * @param {boolean} [hideLauncher] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbedApi
     */
    public embedGetLoader(botId: string, hideLauncher?: boolean, options?: RawAxiosRequestConfig) {
        return EmbedApiFp(this.configuration).embedGetLoader(botId, hideLauncher, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} botId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbedApi
     */
    public embedGetPopupHtml(botId: string, options?: RawAxiosRequestConfig) {
        return EmbedApiFp(this.configuration).embedGetPopupHtml(botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} botId 
     * @param {boolean} [hideLauncher] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbedApi
     */
    public embedGetPopupJs(botId: string, hideLauncher?: boolean, options?: RawAxiosRequestConfig) {
        return EmbedApiFp(this.configuration).embedGetPopupJs(botId, hideLauncher, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} botId 
     * @param {ChatPayload} chatPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbedApi
     */
    public embedSendChat(botId: string, chatPayload: ChatPayload, options?: RawAxiosRequestConfig) {
        return EmbedApiFp(this.configuration).embedSendChat(botId, chatPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IntegrationsApi - axios parameter creator
 * @export
 */
export const IntegrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        azureMessageHandler: async (body: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('azureMessageHandler', 'body', body)
            const localVarPath = `/integrations/azure/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsApi - functional programming interface
 * @export
 */
export const IntegrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async azureMessageHandler(body: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.azureMessageHandler(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.azureMessageHandler']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IntegrationsApi - factory interface
 * @export
 */
export const IntegrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationsApiFp(configuration)
    return {
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        azureMessageHandler(body: any, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.azureMessageHandler(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntegrationsApi - object-oriented interface
 * @export
 * @class IntegrationsApi
 * @extends {BaseAPI}
 */
export class IntegrationsApi extends BaseAPI {
    /**
     * 
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public azureMessageHandler(body: any, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).azureMessageHandler(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ManageApi - axios parameter creator
 * @export
 */
export const ManageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} botId 
         * @param {string} xApiKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (botId: string, xApiKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('_delete', 'botId', botId)
            // verify required parameter 'xApiKey' is not null or undefined
            assertParamExists('_delete', 'xApiKey', xApiKey)
            const localVarPath = `/manage/{botId}/delete`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xApiKey != null) {
                localVarHeaderParameter['X-Api-Key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} botId 
         * @param {string} xApiKey 
         * @param {IBotBaseEmbedConfig} iBotBaseEmbedConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insert: async (botId: string, xApiKey: string, iBotBaseEmbedConfig: IBotBaseEmbedConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('insert', 'botId', botId)
            // verify required parameter 'xApiKey' is not null or undefined
            assertParamExists('insert', 'xApiKey', xApiKey)
            // verify required parameter 'iBotBaseEmbedConfig' is not null or undefined
            assertParamExists('insert', 'iBotBaseEmbedConfig', iBotBaseEmbedConfig)
            const localVarPath = `/manage/{botId}/insert`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['X-Api-Key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iBotBaseEmbedConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} botId 
         * @param {string} xApiKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (botId: string, xApiKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('retrieve', 'botId', botId)
            // verify required parameter 'xApiKey' is not null or undefined
            assertParamExists('retrieve', 'xApiKey', xApiKey)
            const localVarPath = `/manage/{botId}/config`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xApiKey != null) {
                localVarHeaderParameter['X-Api-Key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} botId 
         * @param {string} xApiKey 
         * @param {IBotBaseEmbedConfig} iBotBaseEmbedConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (botId: string, xApiKey: string, iBotBaseEmbedConfig: IBotBaseEmbedConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('update', 'botId', botId)
            // verify required parameter 'xApiKey' is not null or undefined
            assertParamExists('update', 'xApiKey', xApiKey)
            // verify required parameter 'iBotBaseEmbedConfig' is not null or undefined
            assertParamExists('update', 'iBotBaseEmbedConfig', iBotBaseEmbedConfig)
            const localVarPath = `/manage/{botId}/config`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['X-Api-Key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iBotBaseEmbedConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageApi - functional programming interface
 * @export
 */
export const ManageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} botId 
         * @param {string} xApiKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(botId: string, xApiKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(botId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} botId 
         * @param {string} xApiKey 
         * @param {IBotBaseEmbedConfig} iBotBaseEmbedConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insert(botId: string, xApiKey: string, iBotBaseEmbedConfig: IBotBaseEmbedConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsertResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insert(botId, xApiKey, iBotBaseEmbedConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageApi.insert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} botId 
         * @param {string} xApiKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(botId: string, xApiKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(botId, xApiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} botId 
         * @param {string} xApiKey 
         * @param {IBotBaseEmbedConfig} iBotBaseEmbedConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(botId: string, xApiKey: string, iBotBaseEmbedConfig: IBotBaseEmbedConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(botId, xApiKey, iBotBaseEmbedConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageApi - factory interface
 * @export
 */
export const ManageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageApiFp(configuration)
    return {
        /**
         * 
         * @param {string} botId 
         * @param {string} xApiKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(botId: string, xApiKey: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteResponse> {
            return localVarFp._delete(botId, xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} botId 
         * @param {string} xApiKey 
         * @param {IBotBaseEmbedConfig} iBotBaseEmbedConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insert(botId: string, xApiKey: string, iBotBaseEmbedConfig: IBotBaseEmbedConfig, options?: RawAxiosRequestConfig): AxiosPromise<InsertResponse> {
            return localVarFp.insert(botId, xApiKey, iBotBaseEmbedConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} botId 
         * @param {string} xApiKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(botId: string, xApiKey: string, options?: RawAxiosRequestConfig): AxiosPromise<RetrieveResponse> {
            return localVarFp.retrieve(botId, xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} botId 
         * @param {string} xApiKey 
         * @param {IBotBaseEmbedConfig} iBotBaseEmbedConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(botId: string, xApiKey: string, iBotBaseEmbedConfig: IBotBaseEmbedConfig, options?: RawAxiosRequestConfig): AxiosPromise<UpdateResponse> {
            return localVarFp.update(botId, xApiKey, iBotBaseEmbedConfig, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageApi - object-oriented interface
 * @export
 * @class ManageApi
 * @extends {BaseAPI}
 */
export class ManageApi extends BaseAPI {
    /**
     * 
     * @param {string} botId 
     * @param {string} xApiKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageApi
     */
    public _delete(botId: string, xApiKey: string, options?: RawAxiosRequestConfig) {
        return ManageApiFp(this.configuration)._delete(botId, xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} botId 
     * @param {string} xApiKey 
     * @param {IBotBaseEmbedConfig} iBotBaseEmbedConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageApi
     */
    public insert(botId: string, xApiKey: string, iBotBaseEmbedConfig: IBotBaseEmbedConfig, options?: RawAxiosRequestConfig) {
        return ManageApiFp(this.configuration).insert(botId, xApiKey, iBotBaseEmbedConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} botId 
     * @param {string} xApiKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageApi
     */
    public retrieve(botId: string, xApiKey: string, options?: RawAxiosRequestConfig) {
        return ManageApiFp(this.configuration).retrieve(botId, xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} botId 
     * @param {string} xApiKey 
     * @param {IBotBaseEmbedConfig} iBotBaseEmbedConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageApi
     */
    public update(botId: string, xApiKey: string, iBotBaseEmbedConfig: IBotBaseEmbedConfig, options?: RawAxiosRequestConfig) {
        return ManageApiFp(this.configuration).update(botId, xApiKey, iBotBaseEmbedConfig, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} botId 
         * @param {string} xApiKey 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        embedGetSession: async (botId: string, xApiKey: string, chatId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('embedGetSession', 'botId', botId)
            // verify required parameter 'xApiKey' is not null or undefined
            assertParamExists('embedGetSession', 'xApiKey', xApiKey)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('embedGetSession', 'chatId', chatId)
            const localVarPath = `/embed/{botId}/session_data`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = chatId;
            }


    
            if (xApiKey != null) {
                localVarHeaderParameter['X-Api-Key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} botId 
         * @param {string} xApiKey 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {boolean} [hideLauncher] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLoadEmbed: async (botId: string, xApiKey: string, requestBody: { [key: string]: any; }, hideLauncher?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('postLoadEmbed', 'botId', botId)
            // verify required parameter 'xApiKey' is not null or undefined
            assertParamExists('postLoadEmbed', 'xApiKey', xApiKey)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('postLoadEmbed', 'requestBody', requestBody)
            const localVarPath = `/embed/{botId}/load`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hideLauncher !== undefined) {
                localVarQueryParameter['hideLauncher'] = hideLauncher;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xApiKey != null) {
                localVarHeaderParameter['X-Api-Key'] = String(xApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} botId 
         * @param {string} xApiKey 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async embedGetSession(botId: string, xApiKey: string, chatId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmbedGetSession200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.embedGetSession(botId, xApiKey, chatId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.embedGetSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} botId 
         * @param {string} xApiKey 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {boolean} [hideLauncher] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLoadEmbed(botId: string, xApiKey: string, requestBody: { [key: string]: any; }, hideLauncher?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmbedGetLoader200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLoadEmbed(botId, xApiKey, requestBody, hideLauncher, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.postLoadEmbed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} botId 
         * @param {string} xApiKey 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        embedGetSession(botId: string, xApiKey: string, chatId: string, options?: RawAxiosRequestConfig): AxiosPromise<EmbedGetSession200Response> {
            return localVarFp.embedGetSession(botId, xApiKey, chatId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} botId 
         * @param {string} xApiKey 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {boolean} [hideLauncher] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLoadEmbed(botId: string, xApiKey: string, requestBody: { [key: string]: any; }, hideLauncher?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<EmbedGetLoader200Response> {
            return localVarFp.postLoadEmbed(botId, xApiKey, requestBody, hideLauncher, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * 
     * @param {string} botId 
     * @param {string} xApiKey 
     * @param {string} chatId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public embedGetSession(botId: string, xApiKey: string, chatId: string, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).embedGetSession(botId, xApiKey, chatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} botId 
     * @param {string} xApiKey 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {boolean} [hideLauncher] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public postLoadEmbed(botId: string, xApiKey: string, requestBody: { [key: string]: any; }, hideLauncher?: boolean, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).postLoadEmbed(botId, xApiKey, requestBody, hideLauncher, options).then((request) => request(this.axios, this.basePath));
    }
}



